---
layout:     post
title: 买卖股票的最佳时机
subtitle: 121&122&123&188_maxProfit
date:       2019-03-03
author:     Loopy
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - LeetCode
    - List

---

>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
>
>题目:
> - 121.如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
> - 122.设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
> - 123.设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
> - 188.设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
>
>注意:
> - 你不能在买入股票前卖出股票。
> - 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）
>
>121,122,123示例:
>
>>输入: [7,1,5,3,6,4]
>>
>> - 121输出:5
>> - 123输出:7
>> - 124输出:7
>
>188示例:
>
>>输入: [3,2,6,5,0,3], k = 2
>>输出: 7


第二次抽奖又抽到了组合题,还是四合一的

按顺序一道一道来吧

### 1. 暴力(*121*)

要是暴力法,只要求O(n^2)的时间复杂度的话,写起来就很简单

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
      # if all(x>y for x, y in zip(prices, prices[1:])):return 0
      max_profit = 0
      for i in range(len(prices)):
        for j in range(i+1,len(prices)):
          max_profit = max(prices[j]-prices[i],max_profit)
      return max_profit
```
>超出时间限制

---
### 2. 在循环中把历史最小值作为买入值(*121*)

这样就能线性复杂度了

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
      if prices ==[]: return 0
      max_profit = 0
      hist_min_price = prices[0]
      for i in range(len(prices)):
        max_profit = max(prices[i]-hist_min_price,max_profit)
        hist_min_price =min(hist_min_price,prices[i])
      return max_profit
```
>执行用时: 112 ms, 在Best Time to Buy and Sell Stock的Python3提交中击败了6.28% 的用户
>
>内存消耗: 14.1 MB, 在Best Time to Buy and Sell Stock的Python3提交中击败了2.03% 的用户
>
>ps:我已经不相信这个鬼评分系统了

---
### 3. 总是在极小值买入,下一个极大值卖出(*122*)

由于不限制买卖次数,很明显总是在极小值买入,下一个极大值卖出是获利最多的策略

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) <2: return 0

        increase = prices[0]<prices[1]
        buy_price = prices[0]
        max_profit = 0

        for i in range(len(prices)-1):
          if prices[i] < prices[i+1] and increase: # 持续增
            continue
          elif prices[i] > prices[i+1] and not increase: # 持续减
            continue
          elif prices[i] < prices[i+1] and not increase: # 极小值
            increase = True
            buy_price = prices[i]
          elif prices[i] > prices[i+1] and increase: # 极大值
            increase = False
            max_profit += prices[i] - buy_price

        if increase:
          max_profit += prices[i+1] - buy_price
        return max_profit
```

>执行用时: 68 ms, 在Best Time to Buy and Sell Stock II的Python3提交中击败了24.19% 的用户
>
>内存消耗: 14 MB, 在Best Time to Buy and Sell Stock II的Python3提交中击败了0.95% 的用户

### 4. 贪心算法(*122*)

只要能赚,就完成买卖.有点量化交易的感觉

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) <2: return 0
        max_profit = 0
        for i in range(len(prices)-1):
          if prices[i] < prices[i+1]:
            max_profit+=prices[i+1]-prices[i]
        return max_profit
```

>执行用时: 100 ms, 在Best Time to Buy and Sell Stock II的Python3提交中击败了1.46% 的用户
>
>内存消耗: 14.1 MB, 在Best Time to Buy and Sell Stock II的Python3提交中击败了0.95% 的用户

### 5. 叠加做空(*123*)

买卖两次,可以看作单笔买卖,再叠加上一次做空操作.

首先按照第121题的思路,计算出单笔最大获利.再在一次买卖期间计算出一个最大做空获利,做空获利和单笔最大获利加起来就是两笔最大获利

``` python
class Solution:
    def sell_profit(self,prices,head,tail):
      buy_time = sell_time = head
      max_profit = 0
      hist_high_price = prices[head]

      for i in range(head,tail):
        if -prices[i]+hist_high_price > max_profit:
          max_profit = -prices[i]+hist_high_price
          sell_time = i
          buy_time =buy_time_temp
        if hist_high_price < prices[i]:
          buy_time_temp = i
          hist_high_price = prices[i]
      return buy_time,sell_time,max_profit

    def buy_profit(self,prices,head,tail):
      buy_time = sell_time = head
      max_profit = 0
      hist_low_price = prices[head]

      for i in range(head,tail):
        if prices[i] - hist_low_price > max_profit:
          max_profit = prices[i] - hist_low_price
          sell_time = i
        if hist_low_price > prices[i]:
          buy_time = i
          hist_low_price = prices[i]
      return buy_time,sell_time,max_profit  

    def maxProfit(self, prices: List[int]) -> int:
      if len(prices) <2: return 0
      _,_,max_profit_1 = self.buy_profit(prices,0,len(prices))
      buy_time,sell_time,max_profit_2 = self.sell_profit(prices,0,len(prices))

      if max_profit_2> max_profit_1:
        max_profit_1 = max(prices[buy_time+1:])-min(prices[:sell_time])
      else:
        _,_,max_profit_2 = self.sell_profit(prices,buy_time,sell_time)   
      return max_profit_1+max_profit_2
