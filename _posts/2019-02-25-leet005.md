---
layout:     post
title:
subtitle:
date:       2019-02-25
author:     Loopy
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - LeetCode

---

>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

>示例 1：

>>输入: "babad"
>>
>>输出: "bab"
>>
>>注意: "aba" 也是一个有效答案。


### 1.反序最长公共字串

最长公共子串是我们一个比较熟悉的问题,所以我想尽量往上靠

很明显,回文串正读反读都是一样的,所以(是回文串)->(反序是公共字串),而倒过来不一定成立,所以(反序是公共字串)的子串集合包含了(回文串)子串集,那我们就找前者中最长的,再判断是否是回文串,不是就再找下一个最长的,直至找到

既然用到了,就就先把最长公共子串,最长公共子序列写一遍

- 最长公共子串(The Longest Common Substring)
两个字符串张成一个二维区域,区域中每个点记录对应的两个字符的匹配状况(1 or 0),然后寻找最大的对角线为1(都匹配上了)的子区域,既是最大公共字串

``` python
def find_lcsubstr(s1, s2):
	matrix=[[0 for i in range(len(s2)+1)]  for j in range(len(s1)+1)]
	max=0
	p=0
	for i in range(len(s1)):
		for j in range(len(s2)):
			if s1[i]==s2[j]:
				matrix[i+1][j+1]=matrix[i][j]+1
				if matrix[i+1][j+1]>max:
					max=matrix[i+1][j+1]
					p=i+1
	return s1[p-max:p],max

```

- 最长公共子序列 (The Longest Common Subsequence)
我专门写了一篇Blog来分析最长公共子序列的动态规划算法

```python
def find_lcseque(s1, s2):
  matrix=[[0 for i in range(len(s2)+1)]  for j in range(len(s1)+1)]
  for p1 in range(len(s1)):
    for p2 in range(len(s2)):
      if s1[p1] == s2[p2]:
        matrix[p1+1][p2+1] = matrix[p1][p2]+1
      else:
        matrix[p1+1][p2+1] =max(matrix[p1][p2+1],matrix[p1+1][p2])
  return matrix[-1][-1]
```

```python
class Solution:
  def longestPalindrome(self, s: 'str') -> 'str':

```
> |
---
### 2
> |

---
### 3
> |
